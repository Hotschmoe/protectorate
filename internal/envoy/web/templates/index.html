<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protectorate Envoy</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            background: #0d1117;
            color: #c9d1d9;
            min-height: 100vh;
        }
        .header {
            background: #161b22;
            border-bottom: 1px solid #30363d;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .logo {
            font-size: 1.5rem;
            font-weight: 600;
            color: #58a6ff;
        }
        .auth-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .auth-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #f85149;
        }
        .auth-indicator.authenticated { background: #3fb950; }
        .main {
            padding: 2rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }
        .panel {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
        }
        .panel-header {
            padding: 1rem;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-title { font-weight: 600; }
        .panel-body { padding: 1rem; }
        .btn {
            background: #238636;
            color: #fff;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
        }
        .btn:hover { background: #2ea043; }
        .btn-danger { background: #da3633; }
        .btn-danger:hover { background: #f85149; }
        .btn-secondary {
            background: #21262d;
            border: 1px solid #30363d;
        }
        .btn-secondary:hover { background: #30363d; }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            text-align: left;
            padding: 0.75rem;
            border-bottom: 1px solid #21262d;
        }
        th { color: #8b949e; font-weight: 500; }
        .status-running { color: #3fb950; }
        .status-exited { color: #8b949e; }
        .sleeves-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }
        .sleeve-card {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 1rem;
        }
        .sleeve-name {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: #58a6ff;
        }
        .sleeve-meta {
            font-size: 0.875rem;
            color: #8b949e;
            margin-bottom: 1rem;
        }
        .sleeve-actions {
            display: flex;
            gap: 0.5rem;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 2rem;
            width: 400px;
        }
        .modal-title {
            font-size: 1.25rem;
            margin-bottom: 1rem;
        }
        .form-group { margin-bottom: 1rem; }
        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            color: #8b949e;
        }
        .form-input {
            width: 100%;
            padding: 0.5rem;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
        }
        .form-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }
        .terminal-modal {
            width: 80%;
            height: 70%;
            padding: 0;
        }
        .terminal-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .terminal-container {
            height: calc(100% - 50px);
            padding: 0.5rem;
        }
        .full-width { grid-column: 1 / -1; }
        .empty-state {
            text-align: center;
            padding: 2rem;
            color: #8b949e;
        }
        .spawn-loading {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(22, 27, 34, 0.95);
            border-radius: 6px;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 1rem;
        }
        .spawn-loading.active { display: flex; }
        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid #30363d;
            border-top-color: #58a6ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spawn-loading-text {
            color: #8b949e;
            font-size: 0.9rem;
        }
        .modal-content { position: relative; }
        .radio-group {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        .radio-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }
        .radio-option input { cursor: pointer; }
        .form-select {
            width: 100%;
            padding: 0.5rem;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
        }
        .form-select option { background: #0d1117; }
        .form-select option:disabled { color: #6e7681; }
        .hidden { display: none; }
        .ws-status {
            font-size: 0.75rem;
            color: #8b949e;
            margin-left: 0.5rem;
        }
        .ws-status.in-use { color: #f85149; }
        .terminal-status {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 8px;
            vertical-align: middle;
            background: #8b949e;
        }
        .terminal-status.connected { background: #3fb950; }
        .terminal-status.connecting { background: #d29922; animation: pulse 1s infinite; }
        .terminal-status.disconnected { background: #f85149; }
        .terminal-status.error { background: #f85149; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .reconnect-info {
            font-size: 0.75rem;
            color: #8b949e;
            margin-left: 0.5rem;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">Protectorate Envoy</div>
        <div style="display: flex; align-items: center; gap: 1rem;">
            <button class="btn btn-secondary" onclick="openEnvoyTerminal()">Envoy Terminal</button>
            <div class="auth-status">
                <span>Claude Auth:</span>
                <div id="auth-indicator" class="auth-indicator"></div>
            </div>
        </div>
    </header>

    <main class="main">
        <div class="panel">
            <div class="panel-header">
                <span class="panel-title">Docker Containers</span>
                <button class="btn btn-secondary" onclick="refreshContainers()">Refresh</button>
            </div>
            <div class="panel-body">
                <table id="containers-table">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Image</th>
                            <th>Version</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div class="panel">
            <div class="panel-header">
                <span class="panel-title">Docker Networks</span>
            </div>
            <div class="panel-body">
                <table id="networks-table">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Driver</th>
                            <th>Scope</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div class="panel full-width">
            <div class="panel-header">
                <span class="panel-title">Sleeves</span>
                <button class="btn" onclick="showSpawnModal()">+ Spawn Sleeve</button>
            </div>
            <div class="panel-body">
                <div id="sleeves-grid" class="sleeves-grid">
                    <div class="empty-state">No sleeves running. Click "+ Spawn Sleeve" to create one.</div>
                </div>
            </div>
        </div>
    </main>

    <div id="spawn-modal" class="modal">
        <div class="modal-content">
            <div id="spawn-loading" class="spawn-loading">
                <div class="spinner"></div>
                <div class="spawn-loading-text">Spawning sleeve...</div>
            </div>
            <h2 class="modal-title">Spawn New Sleeve</h2>
            <form id="spawn-form" onsubmit="spawnSleeve(event)">
                <div class="form-group">
                    <label class="form-label">Workspace</label>
                    <div class="radio-group">
                        <label class="radio-option">
                            <input type="radio" name="ws-mode" value="new" checked onchange="toggleWorkspaceMode()">
                            Create new
                        </label>
                        <label class="radio-option">
                            <input type="radio" name="ws-mode" value="existing" onchange="toggleWorkspaceMode()">
                            Use existing
                        </label>
                    </div>
                </div>
                <div class="form-group" id="new-ws-group">
                    <label class="form-label">Workspace Name</label>
                    <input type="text" class="form-input" id="new-workspace-input"
                           placeholder="my-project" pattern="[a-zA-Z0-9_-]+"
                           title="Letters, numbers, dashes, underscores only">
                </div>
                <div class="form-group hidden" id="existing-ws-group">
                    <label class="form-label">Select Workspace</label>
                    <select class="form-select" id="existing-workspace-select">
                        <option value="">Loading...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Sleeve Name (optional)</label>
                    <input type="text" class="form-input" id="name-input"
                           placeholder="Auto-assigned from pool">
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="hideSpawnModal()">Cancel</button>
                    <button type="submit" class="btn">Spawn</button>
                </div>
            </form>
        </div>
    </div>

    <div id="terminal-modal" class="modal">
        <div class="modal-content terminal-modal">
            <div class="terminal-header">
                <div style="display: flex; align-items: center;">
                    <span id="terminal-title">Terminal</span>
                    <span id="terminal-status" class="terminal-status"></span>
                    <span id="reconnect-info" class="reconnect-info"></span>
                </div>
                <button class="btn btn-secondary" onclick="hideTerminalModal()">Close</button>
            </div>
            <div id="terminal-container" class="terminal-container"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script>
        let currentConnection = null;

        const TTYD_INPUT = 48;   // '0' - terminal input
        const TTYD_RESIZE = 49;  // '1' - resize command

        function buildTtydMessage(type, data) {
            const msg = new Uint8Array(data.length + 1);
            msg[0] = type;
            for (let i = 0; i < data.length; i++) {
                msg[i + 1] = data.charCodeAt(i);
            }
            return msg.buffer;
        }

        class TerminalConnection {
            constructor(container, wsPath, title) {
                this.wsPath = wsPath;
                this.title = title;
                this.container = container;
                this.term = null;
                this.ws = null;
                this.fitAddon = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 10;
                this.baseDelay = 1000;
                this.maxDelay = 30000;
                this.shouldReconnect = true;
                this.resizeTimeout = null;
                this.resizeHandler = null;
            }

            initTerminal() {
                this.container.innerHTML = '';
                this.term = new Terminal({
                    cursorBlink: true,
                    theme: {
                        background: '#0d1117',
                        foreground: '#c9d1d9'
                    }
                });
                this.fitAddon = new FitAddon.FitAddon();
                this.term.loadAddon(this.fitAddon);
                this.term.open(this.container);
                this.fitAddon.fit();

                this.term.onData((data) => {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(buildTtydMessage(TTYD_INPUT, data));
                    }
                });

                this.resizeHandler = () => {
                    this.fitAddon.fit();
                    this.sendResize();
                };
                window.addEventListener('resize', this.resizeHandler);
            }

            connect() {
                if (!this.term) {
                    this.initTerminal();
                }

                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                this.ws = new WebSocket(`${protocol}//${window.location.host}${this.wsPath}`, ['tty']);
                this.ws.binaryType = 'arraybuffer';

                this.updateStatus('connecting');

                this.ws.onopen = () => {
                    this.reconnectAttempts = 0;
                    this.updateStatus('connected');
                    const initData = JSON.stringify({
                        AuthToken: "",
                        columns: this.term.cols,
                        rows: this.term.rows
                    });
                    this.ws.send(initData);
                };

                this.ws.onmessage = (event) => {
                    const data = new Uint8Array(event.data);
                    if (data.length > 0 && data[0] === TTYD_INPUT) {
                        this.term.write(data.slice(1));
                    }
                };

                this.ws.onerror = () => {
                    this.updateStatus('error');
                };

                this.ws.onclose = (event) => {
                    this.updateStatus('disconnected');
                    if (this.shouldReconnect && !event.wasClean) {
                        this.scheduleReconnect();
                    } else if (this.shouldReconnect) {
                        this.term.write('\r\n[Connection closed]\r\n');
                    }
                };
            }

            scheduleReconnect() {
                if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                    this.term.write('\r\n[Max reconnection attempts reached]\r\n');
                    this.updateReconnectInfo('Max attempts reached');
                    return;
                }

                const delay = Math.min(
                    this.baseDelay * Math.pow(2, this.reconnectAttempts),
                    this.maxDelay
                );
                this.reconnectAttempts++;

                this.updateReconnectInfo(`Reconnecting in ${delay/1000}s (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);

                setTimeout(() => {
                    if (this.shouldReconnect) {
                        this.updateReconnectInfo('');
                        this.connect();
                    }
                }, delay);
            }

            updateStatus(status) {
                const statusEl = document.getElementById('terminal-status');
                statusEl.className = 'terminal-status ' + status;
            }

            updateReconnectInfo(text) {
                const infoEl = document.getElementById('reconnect-info');
                infoEl.textContent = text;
            }

            sendResize() {
                clearTimeout(this.resizeTimeout);
                this.resizeTimeout = setTimeout(() => {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        const json = JSON.stringify({columns: this.term.cols, rows: this.term.rows});
                        this.ws.send(buildTtydMessage(TTYD_RESIZE, json));
                    }
                }, 100);
            }

            dispose() {
                this.shouldReconnect = false;
                clearTimeout(this.resizeTimeout);
                if (this.resizeHandler) {
                    window.removeEventListener('resize', this.resizeHandler);
                    this.resizeHandler = null;
                }
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                if (this.term) {
                    this.term.dispose();
                    this.term = null;
                }
            }
        }

        async function checkAuth() {
            try {
                const resp = await fetch('/api/auth/status');
                const data = await resp.json();
                const indicator = document.getElementById('auth-indicator');
                if (data.authenticated) {
                    indicator.classList.add('authenticated');
                } else {
                    indicator.classList.remove('authenticated');
                }
            } catch (e) {
                console.error('Failed to check auth:', e);
            }
        }

        function parseImageVersion(image) {
            const parts = image.split(':');
            if (parts.length > 1) {
                return { name: parts[0], version: parts.slice(1).join(':') };
            }
            return { name: image, version: 'latest' };
        }

        async function refreshContainers() {
            try {
                const resp = await fetch('/api/docker/containers');
                const containers = await resp.json();
                const tbody = document.querySelector('#containers-table tbody');
                tbody.innerHTML = containers.map(c => {
                    const { name: imageName, version } = parseImageVersion(c.image);
                    return `
                    <tr>
                        <td>${c.name || c.id}</td>
                        <td>${imageName}</td>
                        <td>${version}</td>
                        <td class="status-${c.state}">${c.status}</td>
                    </tr>
                    `;
                }).join('');
            } catch (e) {
                console.error('Failed to fetch containers:', e);
            }
        }

        async function refreshNetworks() {
            try {
                const resp = await fetch('/api/docker/networks');
                const networks = await resp.json();
                const tbody = document.querySelector('#networks-table tbody');
                tbody.innerHTML = networks.map(n => `
                    <tr>
                        <td>${n.name}</td>
                        <td>${n.driver}</td>
                        <td>${n.scope}</td>
                    </tr>
                `).join('');
            } catch (e) {
                console.error('Failed to fetch networks:', e);
            }
        }

        async function refreshSleeves() {
            try {
                const resp = await fetch('/api/sleeves');
                const sleeves = await resp.json();
                const grid = document.getElementById('sleeves-grid');

                if (sleeves.length === 0) {
                    grid.innerHTML = '<div class="empty-state">No sleeves running. Click "+ Spawn Sleeve" to create one.</div>';
                    return;
                }

                grid.innerHTML = sleeves.map(s => `
                    <div class="sleeve-card">
                        <div class="sleeve-name">${s.name}</div>
                        <div class="sleeve-meta">
                            <div>Container: ${s.container_id}</div>
                            <div>Workspace: ${s.workspace}</div>
                        </div>
                        <div class="sleeve-actions">
                            <button class="btn btn-secondary" onclick="openTerminal('${s.name}')">Terminal</button>
                            <button class="btn btn-danger" onclick="killSleeve('${s.name}')">Kill</button>
                        </div>
                    </div>
                `).join('');
            } catch (e) {
                console.error('Failed to fetch sleeves:', e);
            }
        }

        let workspacesCache = [];

        async function refreshWorkspaces() {
            try {
                const resp = await fetch('/api/workspaces');
                workspacesCache = await resp.json();
                updateWorkspaceSelect();
            } catch (e) {
                console.error('Failed to fetch workspaces:', e);
            }
        }

        function updateWorkspaceSelect() {
            const select = document.getElementById('existing-workspace-select');
            if (workspacesCache.length === 0) {
                select.innerHTML = '<option value="">No workspaces available</option>';
                return;
            }
            select.innerHTML = workspacesCache.map(ws => {
                const disabled = ws.in_use ? 'disabled' : '';
                const status = ws.in_use ? ` (in use by ${ws.sleeve_name})` : '';
                return `<option value="${ws.path}" ${disabled}>${ws.name}${status}</option>`;
            }).join('');
        }

        function toggleWorkspaceMode() {
            const mode = document.querySelector('input[name="ws-mode"]:checked').value;
            const newGroup = document.getElementById('new-ws-group');
            const existingGroup = document.getElementById('existing-ws-group');
            const newInput = document.getElementById('new-workspace-input');
            const existingSelect = document.getElementById('existing-workspace-select');

            if (mode === 'new') {
                newGroup.classList.remove('hidden');
                existingGroup.classList.add('hidden');
                newInput.required = true;
                existingSelect.required = false;
            } else {
                newGroup.classList.add('hidden');
                existingGroup.classList.remove('hidden');
                newInput.required = false;
                existingSelect.required = true;
            }
        }

        async function showSpawnModal() {
            await refreshWorkspaces();
            toggleWorkspaceMode();
            document.getElementById('spawn-modal').classList.add('active');
        }

        function hideSpawnModal() {
            document.getElementById('spawn-modal').classList.remove('active');
            document.getElementById('spawn-form').reset();
            hideSpawnLoading();
            toggleWorkspaceMode();
        }

        function showSpawnLoading(msg) {
            document.querySelector('.spawn-loading-text').textContent = msg || 'Spawning sleeve...';
            document.getElementById('spawn-loading').classList.add('active');
        }

        function hideSpawnLoading() {
            document.getElementById('spawn-loading').classList.remove('active');
        }

        async function spawnSleeve(e) {
            e.preventDefault();
            const mode = document.querySelector('input[name="ws-mode"]:checked').value;
            const name = document.getElementById('name-input').value;
            let workspace;

            try {
                if (mode === 'new') {
                    const wsName = document.getElementById('new-workspace-input').value;
                    if (!wsName) {
                        alert('Please enter a workspace name');
                        return;
                    }
                    showSpawnLoading('Creating workspace...');
                    const createResp = await fetch('/api/workspaces', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: wsName })
                    });
                    if (!createResp.ok) {
                        hideSpawnLoading();
                        const err = await createResp.text();
                        alert('Failed to create workspace: ' + err);
                        return;
                    }
                    const wsData = await createResp.json();
                    workspace = wsData.path;
                } else {
                    workspace = document.getElementById('existing-workspace-select').value;
                    if (!workspace) {
                        alert('Please select a workspace');
                        return;
                    }
                }

                showSpawnLoading('Spawning sleeve...');
                const resp = await fetch('/api/sleeves', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ workspace, name: name || undefined })
                });

                if (!resp.ok) {
                    hideSpawnLoading();
                    const err = await resp.text();
                    alert('Failed to spawn sleeve: ' + err);
                    return;
                }

                hideSpawnLoading();
                hideSpawnModal();
                refreshSleeves();
                refreshContainers();
            } catch (e) {
                hideSpawnLoading();
                console.error('Failed to spawn sleeve:', e);
                alert('Failed to spawn sleeve: ' + e.message);
            }
        }

        async function killSleeve(name) {
            if (!confirm(`Are you sure you want to kill sleeve "${name}"?`)) {
                return;
            }

            try {
                const resp = await fetch(`/api/sleeves/${name}`, { method: 'DELETE' });
                if (!resp.ok) {
                    const err = await resp.text();
                    alert('Failed to kill sleeve: ' + err);
                    return;
                }
                refreshSleeves();
                refreshContainers();
            } catch (e) {
                console.error('Failed to kill sleeve:', e);
            }
        }

        function openTerminalWithPath(title, wsPath) {
            document.getElementById('terminal-title').textContent = title;
            document.getElementById('terminal-modal').classList.add('active');
            document.getElementById('reconnect-info').textContent = '';

            const container = document.getElementById('terminal-container');

            if (currentConnection) {
                currentConnection.dispose();
            }

            currentConnection = new TerminalConnection(container, wsPath, title);
            currentConnection.connect();
        }

        function openTerminal(name) {
            openTerminalWithPath(`Terminal - ${name}`, `/sleeves/${name}/terminal`);
        }

        function openEnvoyTerminal() {
            openTerminalWithPath('Terminal - Envoy (Poe)', '/envoy/terminal');
        }

        function hideTerminalModal() {
            document.getElementById('terminal-modal').classList.remove('active');
            if (currentConnection) {
                currentConnection.dispose();
                currentConnection = null;
            }
        }

        checkAuth();
        refreshContainers();
        refreshNetworks();
        refreshSleeves();

        setInterval(() => {
            refreshSleeves();
            refreshContainers();
        }, 5000);
    </script>
</body>
</html>
